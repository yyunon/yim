use log;
use std::env;
use std::fmt;
use std::fs::File;
use std::io::{stdin, stdout, BufReader, BufWriter, Read, Stdin, Stdout, Write};
use std::os::fd::AsRawFd;
use std::process::exit;
use std::str;
use std::string::String;
use syslog::{Error, Facility};

use chrono::offset::Utc;
use chrono::DateTime;
use std::time::SystemTime;

struct SliceDisplay<'a, T: 'a>(&'a [T]);

impl<'a, T: fmt::Display + 'a> fmt::Display for SliceDisplay<'a, T> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut first = true;
        for item in self.0 {
            if !first {
                write!(f, ", {}", item)?;
            } else {
                write!(f, "{}", item)?;
            }
            first = false;
        }
        Ok(())
    }
}

extern crate libc;

extern "C" {
    pub fn getchar() -> libc::c_int;
    pub fn tcgetattr(fd: libc::c_int, termios: *mut libc::termios) -> libc::c_int;
    pub fn tcsetattr(
        fd: libc::c_int,
        optional_actions: libc::c_int,
        termios: *mut libc::termios,
    ) -> libc::c_int;
    pub fn iscntrl(c: libc::c_int) -> libc::c_int;
    pub fn ioctl(fd: libc::c_int, request: libc::c_ulong, ...) -> libc::c_int;
}

fn die(msg: &char) {
    log::error!("{msg}");
    exit(1)
}
struct Keys;
impl Keys {
    fn is_cntrl(c: i32) -> bool {
        c == 127 || (c >= 0 && c <= 31)
    }
    fn cntrl(c: u8) -> u8 {
        c & 0x1f
    }
}

#[derive(PartialEq, Eq, PartialOrd, Ord)]
pub enum CursorDirections {
    Up,
    Down,
    Left,
    Right,
}

#[derive(PartialEq, Eq, PartialOrd, Ord)]
pub enum EditorCommands {
    Exit,
    Healthy,
}

#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Copy, Clone)]
pub enum EditorModes {
    Normal,
    Insert,
}

//#[derive(Copy, Clone)]
struct Terminal {
    raw: libc::termios,
    stdin: Stdin,
    stdout: Stdout,
}
impl Terminal {
    fn new(stdin: Stdin, stdout: Stdout) -> Self {
        let mut raw = libc::termios {
            c_iflag: 0,
            c_oflag: 0,
            c_cflag: 0,
            c_lflag: 0,
            c_line: 0,
            c_cc: [0; 32],
            c_ispeed: 0,
            c_ospeed: 0,
        };
        unsafe { tcgetattr(libc::STDIN_FILENO, &mut raw) };
        Self {
            raw: raw,
            stdin: stdin,
            stdout: stdout,
        }
    }

    fn enable_raw_mode(&mut self) {
        let term_local_flags = libc::ECHO | libc::ICANON | libc::ISIG | libc::IEXTEN;
        let term_input_flags = libc::IXON | libc::BRKINT | libc::ICRNL | libc::INPCK | libc::ISTRIP;
        let term_postporc_flags = libc::OPOST;
        let term_c_flags = libc::CS8;
        unsafe { tcgetattr(self.stdin.as_raw_fd(), &mut self.raw) };
        let mut tmp_raw = self.raw.clone();

        tmp_raw.c_lflag &= !(term_local_flags);
        tmp_raw.c_iflag &= !(term_input_flags);
        tmp_raw.c_oflag &= !(term_postporc_flags);
        tmp_raw.c_cflag |= term_c_flags;

        unsafe { tcsetattr(self.stdin.as_raw_fd(), libc::TCSAFLUSH, &mut tmp_raw) };
    }

    fn control_echo(&mut self, enable: bool) {
        let mut tmp_raw = libc::termios {
            c_iflag: 0,
            c_oflag: 0,
            c_cflag: 0,
            c_lflag: 0,
            c_line: 0,
            c_cc: [0; 32],
            c_ispeed: 0,
            c_ospeed: 0,
        };
        unsafe { tcgetattr(self.stdin.as_raw_fd(), &mut tmp_raw) };

        let term_local_flags = libc::ECHO;
        match enable {
            false => {
                tmp_raw.c_lflag &= !(term_local_flags);
            }
            true => {
                tmp_raw.c_lflag |= term_local_flags;
            }
        }

        unsafe { tcsetattr(self.stdin.as_raw_fd(), libc::TCSAFLUSH, &mut tmp_raw) };
    }

    fn disable_raw_mode(&mut self) {
        unsafe { tcsetattr(libc::STDIN_FILENO, libc::TCSAFLUSH, &mut self.raw) };
    }
    fn read_key(&mut self) -> Option<u8> {
        let mut res: Option<u8> = None;
        let mut buf = [0u8; 1];
        let mut error_handle = false;
        self.stdout.lock().flush().unwrap();
        self.stdin.read_exact(&mut buf).map_err(|err| {
            log::error!("Cannot read key {err}");
            error_handle = true;
        });
        if !error_handle {
            res = Some(buf[0]);
        }
        res
    }
}
impl fmt::Debug for Terminal {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "Terminal {{ raw: {{ c_iflag: {c_iflag:#02x}, c_oflag: {c_oflag:#02x}, c_cflag: {c_cflag:#02x}, c_lflag: {c_lflag:#02x}, c_line: {c_line:#02x}, c_cc: {c_cc:#02x?}, c_ispeed: {c_ispeed:#02x}, c_ospeed: {c_ospeed:#02x} }} }}",
            c_iflag = self.raw.c_iflag,
            c_oflag = self.raw.c_oflag,
            c_cflag = self.raw.c_cflag,
            c_lflag = self.raw.c_lflag,
            c_line = self.raw.c_line,
            c_cc = self.raw.c_cc,
            c_ispeed = self.raw.c_ispeed,
            c_ospeed = self.raw.c_ospeed,
        )
    }
}
impl Drop for Terminal {
    fn drop(&mut self) {
        log::error!("Disabling raw mode");
        self.disable_raw_mode();
    }
}

#[derive(Debug, Default)]
struct AppendBuffer {
    buffer: Vec<u8>,
    size: u32,
    new_lines: Vec<i32>,
}
impl AppendBuffer {
    fn append(&mut self, input_stream: &[u8]) {
        self.buffer.extend_from_slice(input_stream);
        self.size += input_stream.len() as u32;
    }
    fn append_str(&mut self, input_stream: &str) {
        let s = input_stream.as_bytes();
        self.buffer.extend_from_slice(s);
        self.size += s.len() as u32;
    }
    fn insert(&mut self, index: usize, input_stream: u8) {
        self.buffer.insert(index, input_stream);
        self.size += 1;
        self.update_buffers();
    }
    fn remove(&mut self, index: usize) {
        self.buffer.remove(index);
        self.size -= 1;
        self.update_buffers();
    }
    fn find(&self, d: u8) -> usize {
        self.buffer.iter().position(|r| *r == d).unwrap()
    }
    fn write(&mut self, stdout: &mut Stdout) {
        //log::debug!("{}", SliceDisplay(&self.buffer));
        //log::debug!("{:?}", SliceDisplay(&self.buffer));
        if stdout.write(&self.buffer).unwrap() as u32 != self.size {
            log::error!("Couldn't render");
        }
        self.free();
    }
    fn update_buffers(&mut self) {
        self.size = self.buffer.len() as u32;
        // TODO: Don't have to iterate evrytime
        self.new_lines = self
            .buffer
            .iter()
            .enumerate()
            .filter(|(_, d)| **d == b'\n')
            .map(|(i, _)| i as i32)
            .collect::<Vec<i32>>();
    }
    fn free(&mut self) {
        self.size = 0;
        self.buffer.clear();
    }
}
struct Editor {
    mode: EditorModes,
    state: EditorCommands,
    terminal: Terminal,
    rows: i32,
    cols: i32,
    c_x: i32,
    c_y: i32,
    row_offset: i32,
    append_buffer: AppendBuffer,
    append_buffer_insert: AppendBuffer,
    files: String,
    status_message: String,
    status_message_time: SystemTime,
    dirty: i8,
}
impl Editor {
    fn new(stdin: Stdin, stdout: Stdout) -> Self {
        Self {
            mode: EditorModes::Normal,
            state: EditorCommands::Healthy,
            terminal: Terminal::new(stdin, stdout),
            rows: 0,
            cols: 0,
            row_offset: 0,
            c_x: 0,
            c_y: 0,
            append_buffer: AppendBuffer::default(),
            append_buffer_insert: AppendBuffer::default(),
            files: "".to_string(),
            status_message: "".to_string(),
            status_message_time: SystemTime::now(),
            dirty: 0,
        }
    }
    fn init_editor(&mut self) {
        self.c_x = 0;
        self.c_y = 0;
        self.set_window_size();
        self.rows -= 2;
    }
    fn open(&mut self, input_file: &str) -> std::io::Result<()> {
        self.files = input_file.to_string();
        let file = std::fs::OpenOptions::new()
            .create(true)
            .write(true)
            .read(true)
            .open(input_file)?;
        let mut reader = BufReader::new(file);
        reader.read_to_end(&mut self.append_buffer_insert.buffer)?;
        self.append_buffer_insert.update_buffers();
        Ok(())
    }
    fn change_mode(&mut self, m: EditorModes) -> Option<EditorCommands> {
        self.mode = m;
        Some(EditorCommands::Healthy)
    }
    fn set_window_size(&mut self) {
        print!("{esc}[999C", esc = 27 as char);
        print!("{esc}[999B", esc = 27 as char);
        let mut w_size = libc::winsize {
            ws_row: 0,
            ws_col: 0,
            ws_xpixel: 0,
            ws_ypixel: 0,
        };
        unsafe {
            let res = ioctl(
                self.terminal.stdout.as_raw_fd(),
                libc::TIOCGWINSZ,
                &mut w_size,
            );
            if res == -1 || w_size.ws_col == 0 {
                log::debug!("ioctl unsuccesful getting from term");
                if self.terminal.stdout.write(b"\x1b[999C\x1b[998B").unwrap() != 12 {
                    log::error!("Cannot get winsize");
                }
                return self.set_cursor_position();
            } else {
                self.rows = w_size.ws_row as i32;
                self.cols = w_size.ws_col as i32;
            }
            log::debug!("App Rows: {}, Columns: {}", self.rows, self.cols);
        }; // TODO: Handle err
    }
    fn calculate_row_offset(&mut self) {
        if self.c_y < self.row_offset {
            self.row_offset = self.c_y;
        } else if self.c_y >= self.row_offset + self.rows {
            self.row_offset = self.c_y - self.rows + 1;
        }
    }
    fn cursor_limits(&self, t: i32, mode: bool) -> usize {
        if t < 0 {
            return 0;
        }
        match mode {
            false => {
                if t > self.cols {
                    self.cols as usize
                } else {
                    t as usize
                }
            }
            true => {
                if t > self.rows {
                    self.rows as usize
                } else {
                    t as usize
                }
            }
        }
    }
    // Gets the cursor returns the location in the file
    fn calculate_file_index(&self, x: usize, y: usize) -> usize {
        //We know that new lines array is sorted as that is the wau we insert
        let (il, ir) = self.calculate_row_of_insert_indices(y);
        log::debug!("{},{}", il, ir);
        return il + x;
    }
    // Gets the display index row axis index and return row printable c_x, c_y
    fn calculate_row_of_insert_indices(&self, i: usize) -> (usize, usize) {
        if i >= self.append_buffer_insert.new_lines.len() {
            return (0, 0);
        }
        let index_r = self.append_buffer_insert.new_lines[i] as usize;
        let mut index_l = 0;
        if i != 0 {
            index_l = self.append_buffer_insert.new_lines[i - 1] as usize + 1;
        }
        (index_l, index_r)
    }
    fn set_status_message(&mut self, ins: &str) {
        self.status_message = ins.to_string();
    }
    fn clear_status_message_from_editor(&mut self) {
        let status_len: usize = self.status_message.capacity();
        let mut cmd_buffer = String::new();
        cmd_buffer.push(b':' as char);
        for _i in 0..status_len {
            cmd_buffer.push(' ');
        }
        self.terminal.stdout.write(cmd_buffer.as_bytes()).unwrap();
    }
    fn draw(&mut self) {
        for _y in 0..self.rows {
            let file_row = _y + self.row_offset;
            if file_row >= self.append_buffer_insert.new_lines.len() as i32 {
                self.append_buffer.append(b"~");
            } else {
                // TODO Ref here HANDLE COL limits
                let (index_l, index_r) = self.calculate_row_of_insert_indices(file_row as usize);
                self.append_buffer
                    .append(&self.append_buffer_insert.buffer[index_l..index_r]);
            }
            self.append_buffer.append(b"\x1B[K");
            self.append_buffer.append(b"\r\n");
        }
    }
    fn draw_message_bar(&mut self) {
        self.append_buffer.append(b"\x1B[K");
        self.append_buffer.append_str(&self.status_message);
    }
    fn draw_status_bar(&mut self) {
        self.append_buffer.append(b"\x1B[7m");
        //rstatus
        // ROW COUNT
        let mut status = String::new();
        let mut rstatus: String = format!(" [{}/{}] ", self.c_y + 1, self.rows);
        // DATE TIME
        let datetime: DateTime<Utc> = self.status_message_time.into();
        let dt_string = datetime.format("%T %d/%m/%Y").to_string();
        rstatus.push_str(&dt_string);
        // status
        // PRINT mode
        let mode = match self.mode {
            EditorModes::Insert => String::from(" [--INSERT--]"),
            EditorModes::Normal => String::from(" [--NORMAL--]"),
        };
        status.push_str(&mode);
        //FILE NAME
        if self.files.is_empty() {
            status.push_str("[No Name]")
        } else {
            status.push_str(&self.files);
        }
        // DIRTY
        status.push_str(match self.dirty {
            0 => "",
            1 => "(modified)",
            _ => unreachable!("modified or not modified"),
        });

        //WRITE STAT
        if status.len() > self.cols as usize {
            self.append_buffer
                .append_str(&status[0..self.cols as usize]);
        } else {
            self.append_buffer.append_str(&status);
        }
        let mut len = 0;
        while len < self.cols {
            if self.cols - len as i32 - status.len() as i32 == rstatus.len() as i32 {
                self.append_buffer.append_str(&rstatus);
                break;
            } else {
                self.append_buffer.append(b" ");
                len += 1;
            }
        }
        self.append_buffer.append(b"\x1B[m");
        self.append_buffer.append(b"\r\n");
    }
    fn render(&mut self) {
        self.calculate_row_offset();
        self.append_buffer.append(b"\x1B[?25l");
        self.append_buffer.append(b"\x1B[H");
        self.draw();
        self.draw_status_bar();
        self.draw_message_bar();
        self.append_buffer.append_str(
            format!(
                "\x1B[{};{}H",
                (self.c_y - self.row_offset) + 1,
                self.c_x + 1
            )
            .as_str(),
        );
        self.append_buffer.append(b"\x1B[?25h");
        self.append_buffer.write(&mut self.terminal.stdout);
    }
    fn set_cursor_position(&mut self) {
        let mut buffer = [0u8; 32];
        //print!("{}[6n", 27 as char);
        if self.terminal.stdout.write(b"\x1B[6n").unwrap() != 4 {
            log::error!("coulnd't write device status report");
            return;
        }
        self.terminal.stdout.lock().flush().unwrap();
        let mut i = 0;
        //^[[5;1R
        while i < buffer.len() - 1 {
            self.terminal.stdin.read(&mut buffer).unwrap();
            if buffer[i] == b'R' {
                break;
            }
            i += 1;
        }
        buffer[i] = b'\0';

        if buffer[1] != b'[' {
            log::error!("Couldn't parse device status report");
            return;
        }
        self.rows = buffer[2] as i32;
        self.cols = buffer[6] as i32;
    }
    fn process_key_press(&mut self) -> Option<EditorCommands> {
        let key = self.terminal.read_key();
        //let exit_key = Keys::cntrl(b'q');
        match (key, self.mode) {
            (None, _) => None,
            (Some(k), EditorModes::Normal) => self.handle_normal_mode(k),
            (Some(k), EditorModes::Insert) => self.handle_insert_mode(k),
        }
    }
    fn handle_normal_mode(&mut self, k: u8) -> Option<EditorCommands> {
        match k {
            //TODO: These also move cursor
            x if x == Keys::cntrl(b'u') || x == Keys::cntrl(b'd') => self.move_cursor(k),
            b'h' | b'l' | b'j' | b'k' => self.move_cursor(k),
            b'a' => self.move_cursor_insert(k),
            b':' => self.parse_status_cmd_blocking(),
            b'\x1B' => self.change_mode(EditorModes::Normal),
            b'i' => self.change_mode(EditorModes::Insert),
            _ => Some(EditorCommands::Healthy),
        }
    }
    fn naive_move_cursor_2D(&mut self, x: usize, y: usize) {
        // Does not calculate borders
        if self
            .terminal
            .stdout
            .write(format!("\x1B[{};{}H", x, y).as_bytes())
            .unwrap() as u32
            != 5
        {
            log::error!("Couldn't go to command mode",);
        }
    }
    fn naive_move_cursor(&mut self, direction: CursorDirections, offset: usize) {
        // Does not calculate borders
        match direction {
            CursorDirections::Up => {
                if self
                    .terminal
                    .stdout
                    .write(format!("\x1B[{}A", offset).as_bytes())
                    .unwrap() as u32
                    != 3
                {
                    log::error!("Couldn't go to command mode");
                }
            }
            CursorDirections::Down => {
                if self
                    .terminal
                    .stdout
                    .write(format!("\x1B[{}B", offset).as_bytes())
                    .unwrap() as u32
                    != 3
                {
                    log::error!("Couldn't go to command mode");
                }
            }
            CursorDirections::Right => {
                if self
                    .terminal
                    .stdout
                    .write(format!("\x1B[{}C", offset).as_bytes())
                    .unwrap() as u32
                    != 3
                {
                    log::error!("Couldn't go to command mode");
                }
            }
            CursorDirections::Left => {
                if self
                    .terminal
                    .stdout
                    .write(format!("\x1B[{}D", offset).as_bytes())
                    .unwrap() as u32
                    != 3
                {
                    log::error!("Couldn't go to command mode");
                }
            }
        }
    }
    fn save_file(&mut self) -> Result<(), ()> {
        let mut file = std::fs::OpenOptions::new()
            .create(true)
            .write(true)
            .read(true)
            .open(&self.files)
            .map_err(|err| {
                self.set_status_message(format!("{} Cannot save to file", err).as_str());
            })
            .unwrap();
        let mut writer = BufWriter::new(&file);
        file.set_len(self.append_buffer_insert.buffer.len() as u64)
            .unwrap();
        let buffer_len = writer.write(&self.append_buffer_insert.buffer).unwrap();
        self.set_status_message(format!("{} B written", buffer_len).as_str());
        self.dirty = 0;
        Ok(())
    }
    fn exit_editor(&mut self) -> Option<EditorCommands> {
        let _ = self.terminal.stdout.write(b"\x1b[2J");
        let _ = self.terminal.stdout.write(b"\x1b[H");
        Some(EditorCommands::Exit)
    }
    fn run_cmd(&mut self, args: Vec<&str>) -> Option<EditorCommands> {
        //Replace this with YIM engine later
        let args_length = args.len();
        if args_length <= 0 {
            return Some(EditorCommands::Healthy);
        }
        let args_args = &args[1..];
        match args[0] {
            "w" => {
                self.save_file();
                Some(EditorCommands::Healthy)
            }
            "q" => {
                if self.dirty != 0 {
                    self.set_status_message(
                        "You have unsaved changes, press :q! to quit without saving",
                    );
                    Some(EditorCommands::Healthy)
                } else {
                    self.exit_editor()
                }
            }
            "q!" => self.exit_editor(),
            "wq" => {
                self.save_file();
                self.exit_editor()
            }
            _ => {
                self.set_status_message("This command does not exist!!!");
                Some(EditorCommands::Healthy)
            }
        }
    }
    fn parse_status_cmd_blocking(&mut self) -> Option<EditorCommands> {
        //In this mode we show user typed value.
        //self.terminal.control_echo(true);
        // TODO: Hacky render fix alter
        self.naive_move_cursor_2D(self.rows as usize + 2, 0);
        self.clear_status_message_from_editor();
        let mut cmd = String::new();
        self.naive_move_cursor_2D(self.rows as usize + 2, 2);
        // REFREFREFACTOR
        loop {
            let key = self.terminal.read_key();
            if key.unwrap() == b'\x7F' {
                //BACKSPACE is clicked
                // ALL this to have backspace HAHAHA
                cmd.pop();
                self.naive_move_cursor(CursorDirections::Left, 1);
                if self.terminal.stdout.write(b" ").unwrap() as u32 != 1 {
                    log::error!("Couldn't write");
                }
                self.naive_move_cursor(CursorDirections::Left, 1);
                continue;
            }
            if key.unwrap() == 13 as u8 {
                //Until ENTER is clicked
                break;
            } else {
                if self.terminal.stdout.write(&[key.unwrap()]).unwrap() as u32 != 1 {
                    log::error!("Couldn't write",);
                }
            }
            cmd.push(key.unwrap() as char);
        }
        log::debug!("{:?} {}", cmd, cmd.len());
        //self.terminal.control_echo(false);
        self.run_cmd(cmd.split(" ").collect())
    }
    fn handle_insert_mode(&mut self, k: u8) -> Option<EditorCommands> {
        match k {
            b'\x1B' => self.change_mode(EditorModes::Normal),
            b'\x7F' => self.remove_char(),
            _ => self.insert_char(k),
        }
    }
    fn move_cursor_insert(&mut self, k: u8) -> Option<EditorCommands> {
        // TODO: Make here better A lot of repetittions
        let mut row_insert_size = 0;
        if self.c_y < self.rows {
            let (index_l, index_r) = self.calculate_row_of_insert_indices(self.c_y as usize);
            row_insert_size = self.append_buffer_insert.buffer[index_l..index_r].len();
        }
        match k {
            b'a' => {
                if row_insert_size != 0 && self.c_x < row_insert_size as i32 - 1 {
                    self.c_x += 1
                } else if row_insert_size != 0 && self.c_x >= row_insert_size as i32 - 1 {
                    self.c_y += 1;
                    self.c_x = 0;
                }
                self.change_mode(EditorModes::Insert);
            }
            _ => unreachable!(),
        }
        if self.c_y < self.rows {
            let (index_l, index_r) = self.calculate_row_of_insert_indices(self.c_y as usize);
            row_insert_size = self.append_buffer_insert.buffer[index_l..index_r].len();
        }
        if row_insert_size != 0 && self.c_x > row_insert_size as i32 {
            self.c_x = row_insert_size as i32 - 1;
        }
        Some(EditorCommands::Healthy)
    }
    fn move_cursor(&mut self, k: u8) -> Option<EditorCommands> {
        // TODO: Make here better A lot of repetittions
        let mut row_insert_size = 0;
        if self.c_y < self.rows {
            let (index_l, index_r) = self.calculate_row_of_insert_indices(self.c_y as usize);
            row_insert_size = self.append_buffer_insert.buffer[index_l..index_r].len();
        }
        match k {
            b'h' => {
                if self.c_x != 0 {
                    self.c_x -= 1
                } else if self.c_y > 0 {
                    self.c_y -= 1;
                    let (index_l, index_r) =
                        self.calculate_row_of_insert_indices(self.c_y as usize);
                    row_insert_size = self.append_buffer_insert.buffer[index_l..index_r].len();
                    self.c_x = row_insert_size as i32 - 1
                }
            }
            b'j' => {
                //if self.c_y != self.rows - 1 {
                self.c_y += 1
                //}
            }
            b'k' => {
                if self.c_y != 0 {
                    self.c_y -= 1
                }
            }
            b'l' => {
                if row_insert_size != 0 && self.c_x < row_insert_size as i32 - 1 {
                    self.c_x += 1
                } else if row_insert_size != 0 && self.c_x >= row_insert_size as i32 - 1 {
                    self.c_y += 1;
                    self.c_x = 0;
                }
            }
            x if x == Keys::cntrl(b'd') => {
                self.c_y += 20;
            }
            x if x == Keys::cntrl(b'u') => {
                if self.c_y - 20 > 0 {
                    self.c_y -= 20;
                } else {
                    self.c_y = 0;
                }
            }
            _ => unreachable!(),
        }
        if self.c_y < self.rows {
            let (index_l, index_r) = self.calculate_row_of_insert_indices(self.c_y as usize);
            row_insert_size = self.append_buffer_insert.buffer[index_l..index_r].len();
        }
        if row_insert_size != 0 && self.c_x > row_insert_size as i32 {
            self.c_x = row_insert_size as i32 - 1;
        }
        Some(EditorCommands::Healthy)
    }
    fn remove_char(&mut self) -> Option<EditorCommands> {
        log::debug!("{} {}", self.c_x, self.c_y);
        if self.c_x == 0 && self.c_y == 0 {
            return Some(EditorCommands::Healthy); //Early return
        }
        //let (index_l, index_r) = self.calculate_row_of_insert_indices(self.c_y as usize);
        //self.c_x = self.append_buffer_insert.buffer[index_l..index_r].len() as i32 - 1;
        let ind = self.calculate_file_index(self.c_x as usize, self.c_y as usize);
        self.append_buffer_insert.remove(ind - 1);
        self.c_x -= 1;
        if self.c_x == 0 && self.c_y > 0 {
            self.c_y -= 1;
        }
        Some(EditorCommands::Healthy)
    }
    fn insert_char(&mut self, ch: u8) -> Option<EditorCommands> {
        log::debug!("Handling new {}", ch);
        if ch == 13 as u8 || self.c_y == self.cols {
            let ind = self.calculate_file_index(self.c_x as usize, self.c_y as usize);
            self.append_buffer_insert.insert(ind, b'\n');
            self.c_x = 0;
            self.c_y += 1;
        } else {
            let ind = self.calculate_file_index(self.c_x as usize, self.c_y as usize);
            log::debug!("il {}", self.c_x);
            self.append_buffer_insert.insert(ind, ch);
            self.c_x += 1;
        }
        self.dirty = 1;
        Some(EditorCommands::Healthy)
    }
}

fn main() -> std::io::Result<()> {
    syslog::init(Facility::LOG_USER, log::LevelFilter::Debug, Some("yim")).unwrap();
    log::debug!("Launching yim...");
    let args: Vec<String> = env::args().collect();

    let stdin = stdin();
    let stdout = stdout();
    let mut editor = Editor::new(stdin, stdout);

    editor.terminal.enable_raw_mode();
    editor.init_editor();
    let mut openfile = "";
    if args.len() > 1 {
        openfile = &args[1];
        editor.open(openfile)?;
    }
    editor.set_status_message("Welcome Yuksel!");
    loop {
        log::debug!("Mode {:?}", editor.mode);
        log::debug!(
            "C_X {}, C_Y {}, RO {}",
            editor.c_x,
            editor.c_y,
            editor.row_offset
        );
        editor.render();
        let option = editor.process_key_press().unwrap();
        if option == EditorCommands::Exit {
            break;
        }
    }
    Ok(())
}
